一.隔离和隔离级别
ACID(原子性，一致性,隔离性,持久性)

    1.多个事务执行的时候，可能出现的问题：
        a.脏读：读到其他事务未提交的事务
        b.不可重复读：前后读取的记录内容不一致
        c.幻读：前后读取的记录数量不一致
    2.事务的隔离级别：
        a.读未提交：一个事务还没提交时，它做的变更能被其他事务看到
        b.读提交：一个事务提交后，它做的变更才能被其他事务看到
        c.可重复读：一个事务执行过程中看到的数据总是跟这个事务在启动时看到的数据一致
        d.串行化：对同一条数据，写会加写锁，读会加读锁，当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完，才能继续执行
    3.隔离级别的实现：
        a.读提交和可重复读采用视图方式实现，事务访问时，以视图的逻辑结果为准，在可重复读隔离级别下，视图在事务启动时创建，整个事务存在期间都用这个视图；在读提交隔离级别下，视图在每个sql语句执行时创建
        b.读未提交：此隔离级别下直接返回记录上的最新值，没有视图概念
        c.串行化：直接加锁避免并行访问
    4.可重复读的具体实现(mvcc):在mysql中每条记录在更新的时候都会同时记录一条回滚操作，记录上的最新值，通过回滚，就可以得到前一个状态的值(undolog)
    5.为什么可重复读情况下不建议使用长事务：undolog不会一直保留，在不需要的时候(系统里没有比这个回滚日志更早的read-view时)会删除，而由于长事务的存在，undolog必须保留，导致占用大量存储空间；
    另外，长事务还占用锁资源，可能会拖垮整个库。