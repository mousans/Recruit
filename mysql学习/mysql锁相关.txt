一.锁的意义：数据库锁的设计之初是为了处理并发问题，作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则
二.锁的分类：根据加锁范围可以分为：全局锁，表级锁，行级锁
三.具体讨论锁：
    1.全局锁：对整个数据库实例加锁，mysql的加全局读锁的命令为Flush tables with read lock (FTWRL)，加锁后数据更新语句，数据定义语句，和更新类事务的提交语句都会被阻塞
    作用：做全库逻辑备份：也就是把整个库的所有表全查询(select)出来，存成文本
    2.表级锁：mysql的表级锁有两类：表锁和元数据锁
        a.表锁：lock tables ...read/write 与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放，locktables除了限制别的线程读写外，也限定了本线程接下来的操作对象
        b.元数据锁(metadata lock)：MDL不需要显示使用，在访问一个表的时候被自动加上，在执行增删改查的时候，对表加MDL读锁，对表做结构变更的时候加MDL写锁；读锁不互斥，读锁和写锁之间互斥
    3.行锁(InnoDB):
        a.两阶段锁协议：InnoDB事务中，行锁在需要的时候加上，在事务结束，提交之后释放
        b.间隙锁:如果mysql采用rr模式,为了避免幻读,只有行锁不能够达到要求,因为另一个事务如果插入了一个新数据的话,
        也可以被读到,所以mysql推出了间隙锁(锁住两条记录之间的空隙,防止插入)间隙锁默认为两边是开区间
        c.next_key lock:当当前读加的写锁(行锁)和其相邻的间隙锁结合在一起后就形成了next_key锁,其为前开后闭的锁
        d.rr模式下的加锁规则:
            备注:锁是加到索引上的
            两原则:
                a.加锁的基本单位为next_key lock
                b.查找过程中访问到的对象(索引)才加锁
            两优化:
                a.如果是对唯一索引的索引值进行等值查询,则next_key lock退化为行锁
                b.对于等值查询,在最后一个不满足等值条件的的时候,next_key lock 退化为gap lock
            一bug:唯一索引的范围查询会访问到第一个不满足条件的值为止

