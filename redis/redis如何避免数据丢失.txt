一.AOF(日志 避免数据丢失)
    1.AOF记录的内容:redis收到的命令文本
    2.AOF为了避免额外的检查开销,所以AOF不会对命令进行语法检查,所以如果先写日志,后执行命令,日志可能记录了错误的命令;因此,
    AOF先执行redis命令,再写日志,另外后写日志还不会阻塞redis当前的命令执行,响应更快
    3.后写日志的缺点:
        a.如果执行完命令,还没有写日志,redis就宕机了,则这个命令和数据就有可能丢失
        b.AOF后写虽然避免了当前命令的阻塞,但有可能造成下一条命令的阻塞,因为写日志也是再主线程进行的
    4.AOF三种写回策略:
        a.Always(同步写回):每个命令执行完后,立马将日志写回磁盘
        b.Everysec(每秒写回):每个命令执行完后,先把命令写到AOF缓冲区,每隔一秒将缓冲区数据刷到磁盘
        c.No(操作系统控制的写回):每个命令执行完后,先把命令写道AOF缓冲区,由操作系统觉得什么时候写回
    5.AOF日志过大造成的性能问题:
        a.操作系统本身对文件大小有限制,无法保存过大的文件
        b.如果文件过大,追加文件记录效率会变低
        c.如果发送宕机,日志里的命令会被重新执行,如果文件过大,则花费的时间会很多
    6.AOF文件重写机制:redis根据数据库现状创建一个新的AOF文件,读取数据库中的所有键值对,对每一个键值对用一条命令记录它的写入
    这样原本AOF文件中的多条语句就会被压缩为一条语句,实现AOF日志文件的压缩
    7.AOF日志重写的规则:一个拷贝,两处日志
        a.一个拷贝:每次执行重写的时候会从主线程fork一个子线程来进行重写,子线程和主线程共享一个内存空间,这样子线程就可以在
        不影响主线程的请况下把数据拷贝成操作,写入AOF日志
        b.两处日志:如果在重写AOF日志的过程中由写操作到来,redis会把写操作同时计入原本的日志和新生成的日志,这样等拷贝完成后
        就能直接用重写后的AOF文件替代之前的文件了
二.内存快照(RDB):
    1.redis的两个生成RDB的命令:
        a.save:在主线程执行,会导致阻塞
        b.bgsave:创建一个子线程,专门写入RDB,避免阻塞主线程,是redis的默认配置
    2.生成快照的时候,如果保证redis可以继续响应指令:和上面的AOF一样,bgsave是通过fork产生的新进程,而linux的fork采用的是
    写时复制,所以在创建好bgsave子进程那刻起,快照就已经被固定下来
    3.频繁生成快照的缺点:
        a.做快照的时候涉及到大量的磁盘IO(生成快照),会给磁盘很大压力
        b.虽然生成快照的时候采用的是另一个线程不会阻塞主线程,但在fork子线程的时候,涉及复制主线程页表等操作,会阻塞线程
        所以,如果频繁生成快照就会导致主线程阻塞了
    4.解决方法:混合使用AOF日志以及快照RDB
        具体实现:内存快照以一定频率执行,在两次快照之间,使用AOF日志记录操作




