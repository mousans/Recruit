一.单机redis或主从模式,哨兵模式下redis遇到的问题:这几种模式下单个节点都会保存全部数据,当redis的数据量很大时,对硬件(内存)
要求非常高,且如果采用的时RDB模式的持久化,由于数据量很大,在fork的时候,子线程复制主线程的页表,会造成主线程阻塞,由于数据量很大
所以需要花费很多时间去复制页表,从而导致主线程被阻塞很长时间,从而导致redis响应变慢

二.扩展redis:
    1.纵向扩展:在单机的redis上添加内存,硬盘,但这种方法只能解决redis硬件不足的问题,生成RDB文件时,还是会造成redis阻塞
    2.横向扩展:将单个redis主机上的数据划分为多个分片保存到多个redis实例上,构成一个切片集群
三.redis Cluster:
    1.什么是redis Cluster:大量数据下,将数据切片是一种通用的操作,redis Cluster是redis官方提供的一种方案
    2.redis Cluster方案:
        a.采用hash槽来处理数据和实例之间的映射关系,一个切片集群有16384个槽,每个键值对都会被映射到一个槽中,在部署切片集群时
        可以采用手动分配(cluster addslots命令)槽到不同的实例,也可以自动分配(cluster create)平均分配槽到实例
        b.客户端如何定位数据:切片集群中的每个实例都会和其他实例建立连接,将自己的槽的信息发送给其他实例,所以每个实例都有所有
        hash槽的信息,客户端得到hash槽的信息后会将hash槽缓存到本地,当客户端请求键值对的时候,就先计算出槽,然后发送请求
        到对应实例
        c.hash槽的变化:
            a.集群中redis实例有新增或者删除时,redis需要重新分配hash槽
            b.为了实现负载均衡,redis需要把hash槽在所有实例上重新分布
        d.重定位机制:
            d.1.当实例中槽信息发生变化(数据迁移完成):客户端给原实例发送请求时,实例上由于没有数据,所以会响应MOVED命令给客户端,其中就包括
            新实例的ip,客户端将新IP缓存,再向新IP发送请求;
            d.2当槽发送变化,数据正在迁移(数据正在迁移):客户端向原实例发送请求,原实例会回复一个ASK报错信息,提醒客户端槽正在转移,
            让客户端向新实例发送一个ASKING命令(让新实例允许客户端访问),之后再向原实例发送请求,得到数据